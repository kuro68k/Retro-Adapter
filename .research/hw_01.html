<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">




<link rel="stylesheet" href="hw_01_files/adcstyle.css" type="text/css">
<link rel="stylesheet" href="hw_01_files/style.css" type="text/css">


   <title>Technical Note HW01: ADB - The Untold Story: Space Aliens Ate My Mouse</title>


<meta name="categories" content="Hardware">


<meta name="week-posted" content="Aug 31, 1998 - Sep 4, 1998">

<link rel="stylesheet" href="hw_01_files/adcstyle_002.css" type="text/css"><script language="JavaScript" type="text/javascript" src="hw_01_files/adc.js"></script></head><body bgcolor="#ffffff" text="#000000"><a name="//apple_ref/doc/uid/DTS10002470" title="ADB - The Untold Story: Space Aliens Ate My Mouse"></a>
<a name="top"></a>
<!-- top_of_header_marker_comment -->
<!-- begin_header_information --><!-- googleoff: index -->
<center>
	<!-- TOP TABLE CONTAINING LOGO AND SEARCH -->
	<table border="0" cellpadding="0" cellspacing="0" width="600">

		<!-- shim row to hold cells open -->
		<tbody><tr>
			<td><img src="hw_01_files/1dot.gif" alt="" width="300" height="1"></td>
			<td><img src="hw_01_files/1dot.gif" alt="" width="300" height="1"></td>
        </tr>
        <tr> 
			<td><img src="hw_01_files/1dot.gif" alt="" width="300" height="25"></td>
			<td rowspan="3" align="right" valign="bottom"> 


			<!-- START SEARCH TABLE -->
			<form name="MidSearch" method="post" action="http://developer.apple.com/cgi-bin/simpsearch.pl">
				<table align="right" border="0" cellpadding="0" cellspacing="0">
 				<tbody><tr>
					<td><input onblur="if (value == '') {value = 'Search'}" onfocus="if (value == 'Search') {value =''}" value="Search" name="Search" type="text"></td>
					<td><input src="hw_01_files/btn-search.gif" alt="Search" type="image"></td>
				</tr>
				<tr><td colspan="2"><img src="hw_01_files/1dot.gif" alt="" width="1" height="5"></td></tr>
				<tr><td colspan="2"><img src="hw_01_files/1dot.gif" alt="" width="1" height="5"></td></tr>
				<tr><td colspan="2"><a href="http://developer.apple.com/search/" target="_top">Advanced Search</a></td></tr>
				<tr><td colspan="2"><img src="hw_01_files/1dot.gif" alt="" width="1" height="5"></td></tr>
				</tbody></table>
			</form>
			<!-- END SEARCH TABLE -->
			</td>
		</tr>
		
		
        <!-- ADC LOGO -->
		<tr><td align="left" width="300"><a href="http://developer.apple.com/index.html" target="_top"><img src="hw_01_files/developer_connection_title.gif" alt="Apple Developer Connection" border="0" width="245" height="30"></a></td></tr>
		<!-- END ADC LOGO -->
		<tr><td><img src="hw_01_files/1dot.gif" alt="" width="1" height="30"></td></tr>
      </tbody></table>  
	
		<!-- START ADC NAVBAR-->
		<table border="0" cellpadding="0" cellspacing="0" width="600">
		
		<!-- shim row to hold cells open -->
		<tbody><tr>
			<td width="27"><img src="hw_01_files/1dot.gif" alt="" width="27" height="1"></td>
			<td width="273"><img src="hw_01_files/1dot.gif" alt="" width="273" height="1"></td>
			<td width="300"><img src="hw_01_files/1dot.gif" alt="" width="300" height="1"></td>
		</tr>
		
		<tr bgcolor="#dbdbdb"> 
			<td align="right" width="27"><a href="https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/wa/promo?source=ADCLOG&amp;code=ADCLOG-NEX" target="_top"><img src="hw_01_files/member_login_arrow_button.gif" alt="Member Login" border="0" width="25" height="24"></a></td>
			<td style="padding-top: 2px;" align="left" width="273"><a href="https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/wa/promo?source=ADCLOG&amp;code=ADCLOG-NEX" target="_top">Log In</a> | <a href="http://developer.apple.com/membership/" target="_top">Not a Member?</a></td>
			<td style="padding-top: 2px;" align="right" width="300">
            	<a href="http://developer.apple.com/contact/" target="_top">Contact ADC</a>
            	<img src="hw_01_files/1dot.gif" alt="" width="7" height="1"></td>
		</tr>
		<tr bgcolor="#919598">
			<td colspan="3"><img src="hw_01_files/1dot.gif" alt="" width="600" height="1"></td>
		</tr>
		</tbody></table>
<br>
<!-- END ADC NAVBAR-->
<!-- googleon: index --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="http://developer.apple.com/referencelibrary/index.html">Reference Library</a> &gt; <a href="http://developer.apple.com/technicalnotes/index.html">Technical Notes</a> &gt; <a href="http://developer.apple.com/technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="http://developer.apple.com/technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware &amp; Drivers</a> &gt; </p><div style="width: 100%; position: fixed;"><div id="watermark" style="position: relative; margin-left: auto; margin-right: auto; z-index: 20; width: 500px; visibility: hidden;" align="center"><div class="legacybox"><h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="hw_01_files/closebutton.png" alt="close button" border="0" width="14" height="14"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy
section of the ADC Reference Library. This information should not be
used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library &gt; Hardware &amp; Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information -->
<!-- bottom_of_header_marker_comment -->


<!-- top_of_titles_marker_comment --><center><table border="0" cellpadding="0" cellspacing="0" width="600">
<tbody><tr><td scope="row" align="left">
<h1>
<div id="pagehead">Technical Note HW01</div>
<div id="pageheadsub">ADB - The Untold Story: Space Aliens Ate My Mouse</div>
</h1>
</td></tr></tbody></table></center><!-- bottom_of_titles_marker_comment -->

<center><table border="0" cellspacing="1" width="600"><tbody><tr><td align="left">
<!-- begin_header_box -->
<table border="0" cellpadding="0" cellspacing="0" width="600">
    <tbody><tr>
        <td scope="row" align="left" valign="top" width="300">
            <table border="0" cellpadding="0" cellspacing="0" width="300">
			<tbody><tr>            
            <td align="left" width="300"> <img src="hw_01_files/tnmenutop.gif" alt="" align="bottom" width="300" height="7"></td>
                </tr>
                <tr bgcolor="#e6e6e6">
                    <td align="left" background="hw_01_files/tnmenubody.gif" width="300">
                 
                        <span id="menutitle">
                            CONTENTS 
                            <br>
                            <br>
                        </span>
                    </td>
                </tr>
                <tr bgcolor="#e6e6e6">
                    <td align="left" background="hw_01_files/tnmenubody.gif" width="300">
					<!-- begin_toc -->            
         <p id="menutext"><a href="#Section1">The ADB
         Hardware</a><br><br>
         
         <a href="#Section2">The ADB
         Protocol</a><br><br>
         
         <a href="#Section3">ADB
         Drivers</a><br><br>
         
         <a href="#Section4">The Cursor Device
         Manager (CDM)</a><br><br>
         
         <a href="#Section5">Using
         the CDM in Native Code  </a><br><br>
         
        <a href="#Section6">Apple
         Devices</a><br><br>
         
         <a href="#Licensing">Licensing</a><br><br>
         
         
        <a href="#References">References</a><br><br>
         <a href="#Changes">Change History</a><br><br>
         <a href="#Downloads">Downloadables</a></p>
                   <!-- end_toc --> 
                 </td>
                </tr>
                <tr>
                    <td scope="row" align="left" width="300">
                        <img src="hw_01_files/tnmenubottom.gif" alt="" width="300" height="16">
                    </td>
                </tr>
            </tbody></table>
        </td>
        <td align="left" valign="top" width="300">
<!-- begin_intro_text -->
         <p id="introtext">This Technical
         Note explains a number of esoteric and unknown issues
         concerning the Apple Desktop Bus (ADB). It is intended to
         detail information concerning all levels of the ADB, from
         the hardware to the application usage level. This note is
         supplementary to the information in <i>The Guide To
         Macintosh Family Hardware</i> and in the <i>Apple Desktop
         Bus Specification</i>. The information in the specification
         is the most accurate source of data, and unless it is
         specifically refuted, it should be treated as the
         authoritative source.</p>
         
        
     <!-- end_intro_text -->
<!-- begin_date -->
<h3 align="center">[Sep 28 1998]</h3>
<!-- end_date -->
                </td>
             </tr>
          </tbody></table>
          <!-- end_table_box -->
 <br><br>
          <hr align="center" width="500">
          <br><br>
<!-- begin_content -->
         <h2><a name="Section1"></a>The ADB Hardware</h2>
         
         <p>The ADB is a simple serial bus with collision detection.
         A common implementation platform for the protocol is a
         simple microcontroller: a 2-MHz Motorola 68HC11 has been
         used with success, although any number of microcontrollers
         would do a more than adequate job. The 2-MHz clock seemed to
         be close to minimal for this application; the bus has a
         relatively low bandwidth, and, given the packet structure, the
         theoretical maximum bandwidth is on the order of 100 - 200
         bytes/second. In practice, the bus is not suitable for data-
         xtransfer applications; it serves well as a general purpose
         input device bus, but high data rates will not work well.
         </p>
         
         <p>In general, the timing for the ADB is fairly tolerant of
         small variances; however, many Macintoshes are more
         demanding than their predecessors. For this reason, devices
         should be tested on a wide range of machines; the best test
         for compliance is testing. Specifically, the <code>Tlt</code> 
         (stop to start time) parameter has become much less tolerant; fairly
         close adherence to its 200-<i>us</i> timing is important. In
         particular, devices which respond more rapidly than the 140-<i>us</i> 
         minimum delay will often fail to initialize properly.
         </p>
         
         <p>It is important that your device be fairly tolerant of
         problems on the bus; if a command packet begins but never
         seems to complete, your device should time out rather than
         hang.  The design of the bus and its connectors means that
         there can be occasional glitches in the connection with the
         host, and you should try to be as tolerant of these as
         possible.</p>
         
         <p>Because the ADB bus is open collector, collisions can be
         detected when a device is attempting to drive the bus high
         and another device pulls it low. This means that whenever
         the device is driving the bus high, it should be watching to
         make sure the bus is actually high; if the bus goes low,
         some other device is sending at the same time. When a device
         detects a collision, it should immediately stop
         transmitting: this means that if two devices are colliding,
         one of them will detect the collision, while one will not.
         This occurs because a device can only detect the collision if it
         is driving the bus high and another device drives it low.
         The device driving it low has no way to tell that there was
         a collision, as the bus follows it. Since the detecting
         device immediately stops transmitting, the other device will
         not detect the collision. Thus, if there are a number of
         devices transmitting on the bus, only one of them will
         complete its transmission without detecting the collision,
         unless the unlikely occurrence of more than one device
         transmitting exactly the same data with the same timing
         occurs, and neither detects the collision.</p>
         
         <p>The ADB is not particularly tolerant of devices being
         connected and disconnected while the bus is live. There
         isn't any software architecture to detect the presence of
         new devices or the absence of old ones; furthermore, on some
         CPUs, the motherboard is not well protected from voltage
         transients on the ADB connector.  Plugging in a device while
         the Macintosh is powered on could cause damage to the ADB
         transceiver or other portions of the Macintosh's circuitry.
         </p>
         
         <p>On some portable Macintoshes, the voltage characteristics
         do not adhere to the ADB specification. Clearly, power is very 
         valuable on all portable computers, so if your device is targeted 
         towards portable use, you should be extremely careful to keep 
         your power consumption as low as possible.  While the ADB can 
         supply the full voltage stated in the specification, drawing 
         this much power will lead to much more rapid battery draining. On 
         the PowerBook 140 and 170, there was a specific problem which
         caused the low-level input voltage to go above the specified
         maximum of 0.8 volts: it commonly came close to 1.5 volts.
         This has caused problems for some third-party devices, and it
         has been corrected on subsequent machines. (There is a
         recommended service procedure for repairing this problem
         available from Apple Service representatives, should this be
         a problem for a user.)</p>
         
         <h3>Soft Power</h3>
         
         <p>On Macintoshes with software power control, the machine
         can be turned on by an ADB device. This is accomplished by
         momentarily connecting pin 2 on the ADB connector (reserved)
         to pin 4 (ground). Pin 2 should be kept grounded until pin 3
         (+5 volts) comes up to power, letting you know that the
         machine has actually come on. Some Macintoshes do not have
         soft-power capabilities; on these machines, grounding pin 2
         will have no effect.</p>
         
         <p><a href="#top">Back to top</a></p><h2><a name="Section2"></a>The ADB Protocol</h2>
         
         <h3>Registers</h3>
         
         <p>Each ADB device has four logical registers; the host can
         ask the device to talk to or listen on each one of these
         registers.  A talk command asks the device to output the
         stored value from that register; a listen commands asks the
         device to accept a new value for that register. A register
         can contain between two and eight bytes. Some of the registers
         have predefined functions: register 0 is used as the primary
         data transfer register for most devices; it is this register
         which is polled by the input mechanism (as described below).
         Register 1 has no specified use; it is available for any use
         the device might require. Register 2 has no specified use
         for most devices; the ADB specification does define an
         "extended address device" protocol for register 2 on devices
         at address 1, but this is unused by most developers.
         Register 3 is used to identify devices and to separate
         devices which occupy the same address, as discussed in
         "Address Resolution" below.</p>
         
         <a name="Default"></a>
        <h3> Default addresses and handler
         IDs</h3>
         
         <p>Each ADB device identifies its software interface with
         two constants: the default address and the handler ID. This
         pair uniquely identifies a device's software interface; the
         default address usually specifies a device's general type
         (such as relative pointing device or keyboard), while the
         handler ID specified the particular data protocol this
         device uses for communication. The default address
         categories are as follows:</p>
         <br>
         <table border="1" width="100%">
            <tbody><tr>
               <td align="center" width="81">
                  <b>Default<br>
                  
                  Address</b>
               </td><td align="left">
                  <b>Device Type</b>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>1</p>
               </td><td align="left">
                  <p>Security and Dongles</p>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>2</p>
               </td><td align="left">
                  <p>Keyboards</p>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>3</p>
               </td><td align="left">
                  <p>Relative pointing devices (mice)</p>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>4</p>
               </td><td align="left">
                  <p>Absolute pointing devices (tablets)</p>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>5</p>
               </td><td align="left">
                  <p>Low speed data transfer devices</p>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>6</p>
               </td><td align="left">
                  <p>Reserved (PowerBook Duo charger)</p>
               </td></tr>
            <tr>
               <td align="center" width="81">
                  <p>7</p>
               </td><td align="left">
                  <p>Appliances (Miscellaneous catch-all)</p>
               </td></tr>
         </tbody></table>
         
         <br>
         <h3>Table 1 -Default address categories</h3>
         
         <p>The default address is only a guide; there's no real
         reason a mouse can't be at address 7, but default addresses
         are assigned on a category basis to try to avoid the case
         where a user has more than one device at a particular
         address. By putting all the relative devices at address 3,
         collisions will be avoided at address 3 for all users who
         have only one relative pointing device. While the bus is
         robust with respect to separating devices which are at the
         same address, the ADBS driver-loading mechanism, which is
         described below, made it useful to try to avoid having
         several dissimilar devices at the same address.</p>
         
         <p>Default addresses and handler IDs are assigned by Apple
         Software Licensing when an ADB license contract is
         completed. Default address 0 is used by the ADB host;
         addresses 8 through 15 are used as locations for 
         locating devices dynamically.</p>
         
         <p>Some devices support more than one data protocol. An
         example is the extended keyboard, which can be asked to send
         separate key codes for the left and right shift keys. This
         change is accomplished by changing its handler ID to 3; the
         new handler ID reflects the new data protocol. If your
         device receives a request to change handler IDs (via a
         listen register 3 command), it should only obey the request
         if it knows how to speak the protocol specified by the new
         handler ID. For example, the extended keyboard, when
         receiving a request to change handler IDs, should accept the
         change if it is going to ID 3 or some other ID it knows
         about, and should thereafter report that ID as its own in
         response to talk register 3 commands.  If it receives a
         request to change to handler ID <code>$52</code>, it should ignore it, as
         it does not know what handler ID <code>$52</code> implies, and continue
         to report its original handler ID in response to talk
         register 3 commands.</p>
         
         <p>A special case is devices which emulate Apple device
         protocols. For example, you may be constructing a 17-button
         mouse for use by specially trained squid; this device has a special
         software protocol to allow it to convey the state of all 17
         mouse buttons. However, you may wish to emulate the Apple
         mouse protocol so your device can be used as a one-button
         mouse on machines which don't have your driver software
         installed. Due to the software design of the ADB Manager, if
         your device is at default address 3, it will have the
         default mouse driver installed as its driver at startup
         regardless of its handler ID. When your software loads, you
         can install a new driver for your device and tell it to
         begin talking the 17-button protocol. You have two options:
         </p>
         
         <ol>
            <li>You can have your device power up with the default
            Apple mouse handler ID (<code>$01</code>) or with your own handler ID
            as assigned by Apple Software Licensing. If you power up
            with the <code>$01</code> handler ID, your software will have to
            locate your device by trying to change the handler ID of
            each device which started out at address 3 to you custom
            ID, then reading the handler ID of that device back. If
            the change sticks, then you know you're talking to your
            device, and can install your custom driver. In addition,
            the command to change handler IDs told the device to
            begin using your custom protocol.</li>
            
            <li>Alternatively, you could have your device power up
            with your custom handler ID; this would make identifying
            your device somewhat easier, as your device could be
            identified by its special handler ID. However, you would
            have to use some special command to tell the device that
            you have installed the new driver and that it can begin
            speaking the custom protocol. For example, you could use
            a talk register 1 to tell the device that you're ready
            for the 17-button data protocol.</li>
         </ol>
        
         <p>Both approaches work well, but the first one is
         recommended.  It ensures that the current protocol can always
         be determined by looking at the current handler ID; however,
         it relies on all devices at that default address handling
         commands asking them to change to a different handler ID
         properly, as a device which incorrectly changes its handler
         ID to your assigned ID would fool you into thinking it was
         your device. This doesn't seem to be a large problem, but
         there could be some obscure devices with this bug.</p>
         
         <h3>Address Resolution</h3>
         
         <p>Address resolution is the process the ADB Manager uses to
         separate devices that share the same default address so
         they power up shadowing each other at a particular address.
         It relies on devices using collision detection to determine
         when there is more than one device at a particular address.
         </p>
         
         <p>An ADB device's register 3 is 2 bytes long, and includes 4
         bits in which the address is stored. When the device
         receives a listen register 3 command, it should take its
         address from this 4-bit field. When it receives a talk
         register 3 command, it would be redundant to put the
         device's address in that field: the device's address is
         already uniquely determined by the fact that the device is
         responding to the talk register 3 command, which was sent to
         a specific address. Instead, a random 4-bit value should be
         returned in this field; this makes it easier to detect
         collisions between two devices responding to a talk register
         3.</p>
         
         <p>When a device receives a talk register 3 command, it
         should send back all of register 3, including the random
         field, and it should pay careful attention to collision
         detection. Should a device detect a collision when
         responding to a talk register 3 request, there is a special
         provision in the ADB protocol which says that the device
         should ignore the next listen register 3, which asks it to
         change address. The next time the device receives a listen
         register 3 command, it should check to see if the handler ID
         field is set to <code>$FE</code>. This is a reserved handler ID
         used to distinguish this type of listen request. If the handler
         ID field is <code>$FE</code>, the device should only change
         address if it has safely transmitted a complete packet since
         its last collision. Of course, the device should not adopt the
         handler ID of <code>$FE</code>.</p>
         
         <p>Here is a summary of a typical sequence where the host is
         attempting to separate two devices. There are two devices of
         the same type, which I will call Fred and Wilma, at address
         3.</p>
         
         <ol>
            <li>The host will send a talk register 3 command to
            address 3.</li>
            
            <li>Both Fred and Wilma will receive the command and
            begin to respond.</li>
            
            <li>Even though they are sending the same data, and they
            begin sending at the same time, they select different
            random numbers to insert into the "device address" field
            of register 3, bits 7-10.</li>
            
            <li>Wilma detects a collision while trying to send bit 7
            and immediately stops sending.</li>
            
            <li>Fred does not detect a collision and completes his
            transmission of register 3.</li>
            
            <li>The host, seeing that a device has responded to its
            talk register 3, sends a listen register 3 to address 3,
            asking the device there to move to address <code>$F</code>.
            The handler ID field is <code>$FE</code>, indicating that a
            device should not move if it has detected a collision.</li>
            
            <li>Both Fred and Wilma receive the request.</li>
            
            <li>Fred moves to address <code>$F</code>; however, Wilma
            does not, as she has been locked out of moving because she
            detected a collision while responding to her last talk
            register 3 command.</li>
            
            <li>The host sends a talk register 3 to address
            <code>$F</code> to ensure that a device moved there. Fred
            responds, assuring the host he has moved.</li>
            
            <li>The host repeats the separation procedure, sending a
            talk register 3 to address 3, followed by a listen
            register 3 to address 3, asking the device there to move
            to address <code>$E</code>.</li>
            
            <li>This time, Wilma does not detect a collision, as she
            is the only device remaining at address 3, so she moves
            to address <code>$E</code>.</li>
            
            <li>The host sends yet another talk register 3 to address
            3, but does not receive a response, as there are no more
            devices remaining at address 3.</li>
            
            <li>The host relocates Wilma from address <code>$E</code>
            back to address 3, with a listen register 3 command sent to
            address <code>$E</code>.</li>
            
            <li>The host moves on and repeats the process for address
            4.</li>
         </ol>
         
         <p>Each and every ADB controller isn't guaranteed to follow
         this procedure precisely, but it gives a feeling for the
         principle behind the address resolution process. You may see
         some implementations moving devices many more times than is
         necessary.  This is done because some devices have been
         manufactured to tolerances close enough that not only do
         they send their bits at exactly the same time and so cannot
         detect collisions with each other, but they select the same
         random numbers to transmit. We recommend that you include
         some low-tolerance device (such as a capacitor on your reset
         line) to ensure that various devices will respond
         differently and be able to detect their collisions with each
         other.</p>
         
         <h3>Autopolling</h3>
         
         <p>Autopolling is the primary method by which the host
         fetches data from your device. The host repeatedly issues talk
         register 0 commands to your device; if your device responds
         with data, it is passed to your device's driver, which should
         act on it as new data.
         </p>
         
         <p>This implies that register 0 should be the primary data
         transfer register for most devices; registers 1 and 2 are
         usually only used for supplementary data to configure the
         device. Most device drivers have no need to issue commands
         to their device, as all necessary data has been transferred
         within register 0.</p>
         
         <p>When a device wishes to transmit data, it should wait
         until a command is issued to it or some other device. If,
         when this transmission is completing, it still wishes to
         transfer data (if the command was sent to our device, it
         might have fetched the data already), it should assert SRQ
         after the data portion of the command by holding the bus low
         for 300 <i>us</i> after the stop bit. This will alert the host
         that some device wishes to transmit data. It will then begin
         polling those addresses which it knows hold devices. If a
         device does not have any data, the host will move on to the
         next address, asking each device in turn, until SRQ is no
         longer asserted, indicating that all pending data has been
         fetched.</p>
         
         <p>When an SRQ is not asserted, the host will continually
         poll the last device to send it data, sending it talk
         register 0 commands periodically. This is done under the
         assumption that this is likely to be the next place the user
         interacts; if the user types a character, she is very likely
         to type another soon. On current hosts, this can happen up
         to 150 times a second, although it can happen much less
         frequently in some cases. If the device responds with any
         data, the host will call the device's driver with the data.
         </p>
         
         <p>Your device should only respond with data when sent a
         talk register 0 command if it has new data. If the status of
         the device has not changed since the last talk register 0,
         then it should not respond at all, allowing the bus to time
         out. This is useful for two reasons.  First, it tends to
         reduce the demands on the host, as your driver need not be
         called when your device has nothing useful to say. Second,
         in some ADB implementations, the host can get "hung up" on
         your device if you always respond. For example, say that you
         have a device at address 4 which will always respond
         regardless of whether it has new data; there is another
         device at address 7.  Moreover, the system is currently
         autopolling address 2. If the device at address 7 asserts SRQ,
         the system will begin looking through the addresses for
         the device which has data to send. When it reaches your
         device at address 4, your device will respond, although it
         has nothing new to say. On some implementations, this will
         cause the host to repeatedly ask your device for more data,
         and your device will continue responding. Meanwhile, device
         7 is withering away at the end of the bus, and will never get
         serviced. What your device should do is not respond to the
         talk register 0 (since it has no new data); this will allow all
         host implementations to pass you by and reach the device at
         address 7, which needs the host's attention.</p>
         
         <p>A useful summary of a reasonable algorithm is:</p>
         
         <ul>
            <li>Wait for a command to begin.</li>
            
            <li>If the command is directed to my address, handle it.
            If it is a talk register 0 command, only respond if there
            is new data waiting to be sent.</li>
            
            <li>At the end of the command, if there is data waiting
            to be sent, assert SRQ, regardless of whom the original
            command was directed toward.</li>
         </ul>
         
         <p>This simple behavior will produce the appropriate
         responses and SRQ generation for proper bus functioning. It
         shouldn't be necessary for your device to have any 
         explicit knowledge of whether it is the "active" device or not;
         a robust basic behavior will eliminate any need for such
         information.</p>
         
         <p>As an optimization, all recent versions of the ADB
         Manager will not automatically poll a device which does not
         have a driver service routine installed. In this case, they
         will switch to autopolling some other device, even if the
         manager has not been recently communicated with that device.
         However, the host may poll a device, even if it does not have a
         service request, in order to try to clear an SRQ on the
         bus.</p>
         
         <h3>Bus Initialization</h3>
         
         <p>Bus initialization doesn't work exactly as it might seem
         from looking at some documentation. A <code>SendReset</code>
         command is never sent to individual devices; rather, when a bus
         reset is requested, the ADB Manager sends a
         <code>SendReset</code> command which is broadcast to all
         devices, causing them to reset themselves and go to their
         default addresses and handler IDs. The relocation and driver
         loading procedure will follow immediately after the reset
         command is sent.</p>
         
         <p><a href="#top">Back to top</a></p><h2><a name="Section3"></a>ADB
          Drivers</h2>
         
         <h3>Driver Installation</h3>
         
         <p>In the past, the recommended way to install an ADB driver
         was to install a resource of type <code>'ADBS'</code> with the
         same resource ID as your device's default address in the
         system file (which held code to install the driver for the
         ADB driver, along with the driver itself). When the system
         was booted or when the bus was reinitialized, the system
         would get the <code>'ADBS'</code> resource and execute it,
         which would let your code set up the driver for that device.
         Unfortunately, this system is not well-designed for the wide
         variety of devices available; the most prominent flaw is
         that the <code>'ADBS'</code>resources are indexed by default
         address only.  Thus, there is no way to use the
         <code>'ADBS'</code> mechanism to load drivers for two different
         devices at address 7, since there can be only one resource with
         ID 7. A further flaw is that it requires installation into
         the system file, which is not currently recommended for a
         number of reasons. In any case, it has always required a
         special installation and deinstallation program, which has been
         more than a little confusing for users.</p>
         
         <p>Currently, the recommended method is to supply the user
         with a system extension which will load your driver.  This
         can either be a simple extension, or it can be contained
         within a control panel, should your device require some user
         interface for configuration. Your code, when loaded, should
         look for your device and install your driver for it. If your
         device is at a default address which is not shared with
         standard Apple devices, you don't have to concerned with
         what driver is installed for you by default--your device can
         just power up at its standard address with its handler ID.
         Your extension can then locate your device's current address
         by indexing through all the known devices with the ADB
         Manager call <code>GetADBInfo</code>. When you find a device
         whose initial address and handler ID match your device's,
         you can call <code>SetADBInfo</code> to install your driver's
         completion routine to handle autopolled data from your
         device.</p>
         
         <p>Because your ADB driver is in a system extension which
         will not load until well into the system startup process, you
         might need to provide standard system functionality before your
         driver loads in order to allow the user to interact with the
         system during the startup process if your device is a standard
         one (a pointing device or keyboard).
         
         This arrangement also allows the user to use your device to
         control their machine even if they don't have the software
         installed, such as when they are booting from a floppy. In
         this case, your device will need to be able to emulate the
         Apple protocol for mouse or keyboard devices until your
         software driver loads, as discussed above in
         <a href="#Default">"Default
         Addresses and Handler IDs"</a>. Until your driver is
         installed, your device will be serviced by the default
         driver for this address. Even if it cannot emulate an Apple
         device, a device at address 2 or 3 must supply harmless data
         in register 0 until your driver loads and is installed, as
         the Apple ADB driver for that address may inadvertently
         receive the contents of your register 0 and attempt to use
         it as input data. If the data in your field caused effects
         such as the mouse button or shift key sticking down, this
         could cause problems for the user.</p>
         
         <p>If you use the recommended procedure for handler IDs in
         this case (powering up with the appropriate Apple handler ID
         and switching to your custom ID when your driver loads), you
         will need to use ADB commands to find your device at
         startup. You should index through the connected ADB devices
         with <code>GetADBInfo</code>, and if you find a device that
         has an original address and handler ID which indicates that it
         might be your device, attempt to switch it to your handler
         ID by using <code>ADBOp</code> to send it a listen register 3
         to change its handler ID. (You will first need to read its
         register 3 with a talk register 3 command so you can
         correctly copy the various flag bits in the register you
         send to the device.) You should then issue a talk register 3
         command to the device and examine the response to see if the
         new handler ID was accepted and reported back by the device.
         If so, you can be certain that this device is yours,
         and you can then call <code>SetADBInfo</code> to install your
         driver as the handler for that device.</p>
         
         <p>In the original method using <code>'ADBS'</code> resources,
         the system could automatically reload your driver any time
         the bus was reinitialized. If your driver is loaded via a
         system extension, there isn't any way for the system to find
         your device and driver, and reconnect them after the bus is
         reinitialized and devices are relocated. Thus, you must
         manually reconnect your driver to your device each time the
         bus is reinitialized. Fortunately, there is a system
         provision for you to be notified each time the bus is
         reinitialized. There is a low-memory global called
         <code>jADBProc</code> (at address <code>$6B8</code>) which is a
         pointer to a procedure to be called just before and just after
         the bus is initialized. When the procedure is called before the
         bus is initialized, register <code>D0</code> is set to 0;
         afterword, it is set to 1. When your extension loads and
         installs your driver, you should remember the value in the
         <code>jADBProc</code> global and then install a pointer to a
         procedure of your own in that location. When your procedure
         is called and has finished its processing, it should then
         call through to the previous procedure whose address was in
         <code>jADBProc</code> before you replaced it. (If
         <code>jADBProc</code> was equal to 0 before you installed, just
         return from your procedure.) Don't forget to preserve
         register <code>D0</code> so subsequent procedures can tell if
         they are being called before or after the reinitialization.
         The actions you take in the post-initialization case should
         basically duplicate your original installation procedure,
         including looking through all the devices for devices of
         your type and calling <code>SetADBInfo</code> to install your
         driver for your devices.</p>
      
      
         <p>For history buffs, this is the second time the
         recommended procedure for loading ADB drivers has changed.
         Initially, it was recommended that ADB drivers be loaded
         with INITs; however, at the time, <code>jADBProc</code> did not
         exist, so when the Macintosh Portable came out, INIT-handled
         devices had the fatal flaw of not reloading their drivers when
         the Macintosh was put to sleep and reawakened, since this
         procedure involved resetting the bus. This caused us to
         begin recommending the use of the <code>'ADBS'</code> resource,
         since in this way the driver could be reloaded from the System
         file.  However, the <code>'ADBS'</code> approach has so many
         major flaws that we have stopped recommending it now that the
         <code>jADBProc</code> global has been introduced. The
         <code>jADBProc</code> global has been available since System
          6.0.4.</p>
         
         <p>For true history buffs, or possibly for specialized
         applications, here is the description of the
          <code>'ADBS'</code> resource functionality. The
          <code>'ADBS'</code> resource is loaded into the 
          system heap by the system and detached with
         <code>DetachResource</code>. The resource is then called by
         <code>JSRing</code> to the first byte of the
         resource. At this time, the registers are set up as follows:
         <code>A0</code> holds the address of the <code>'ADBS'</code>
         resource data (although it is no longer in a resource handle,
         thanks to the <code>DetachResource</code> call); if a handle to
         the resource is needed, <code>RecoverHandle</code> can be
         called to retrieve it. The low byte of register <code>D0</code>
         holds the ADB device's current address (due to
         relocation, this might not be the same as the default
         address) and the low byte of register <code>D1</code> holds 
         the handler ID of the device in question.</p>
     
<p><a href="#top">Back to top</a></p><h2><a name="Section4"></a>
The Cursor Device Manager</h2>


         <p>In order to be able to manage an expanding set of
         relative movement devices, Apple has created the Cursor
         Device Manager, which is a software architecture which
         provides a standard interface to devices of widely varying
         resolutions and capabilities. This also allows better
         management of multiple relative devices on a single bus. In
         the old architecture, all connected devices shared a single
         button state and acceleration curve, which became a problem
         for Apple and for third-party device manufacturers. The
         Cursor Device Manager provides a number of calls for
         finding, configuring, and manipulating relative devices
         connected to the bus. It also supports the new extended
         mouse protocol, which is described below in the "Apple
         Devices" section.</p>

         <h3>Cursor Device Manager types</h3>

      <p>The Cursor Device Manager treats each relative or
         absolute device as a <b>Cursor Device</b>. Each one is
         specified by a <code>CursorDeviceRec</code> which is defined as
         follows:</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
	<td align="left" bgcolor="#e6e6e6">
<pre>typedef struct CursorDevice {
    struct CursorDevice    *nextCursorDevice;    // pointer to next record in
                                                 // linked list
    CursorData             *whichCursor;         // pointer to data for target cursor
    long                   refCon;               // application-defined
    long                   unused;               // reserved for future
    OSType                 devID;                // device identifier (from ADB reg 1)
    Fixed                  resolution;           // units/inch (orig. from ADB reg 1)
    UInt8                  devClass;             // device class (from ADB reg 1)
    UInt8                  cntButton;            // number of buttons (from ADB reg 1)
    UInt8                  filler1;              // reserved for future
    UInt8                  buttons;              // state of all buttons
    UInt8                  buttonOp[8];          // action performed per button
    unsigned long          buttonTicks[8];       // ticks when button last went
                                                 // up (for debounce)
    long                   buttonData[8];        // data for the button operation
    unsigned long          doubleClickTime;      // device-specific double click speed
    Fixed                  acceleration;         // current acceleration
    short                  privateFields[15];    // fields used internally to CDM
}CursorDevice,*CursorDevicePtr;</pre>
	</td>
</tr>
</tbody></table></center>

<p>The cursor controlled by this cursor device is described
         with a <code>CursorDataRec</code>:</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
	<td align="left" bgcolor="#e6e6e6">
<pre>typedef struct CursorData {
    struct CursorData    *nextCursorData;      // next in global list
    Ptr                  displayInfo;          // unused (reserved for future)
    Fixed                whereX;               // horizontal position
    Fixed                whereY;               // vertical position
    Point                where;                // the pixel position
    Boolean              isAbs;                // has been stuffed with absolute coords
    UInt8                buttonCount;          // number of buttons currently pressed
    long                 screenRes;            // pixels per inch on the current display
    short                privateFields[22];    // fields use internally by CDM
}CursorData,*CursorDataPtr;</pre>
	</td>
</tr>
</tbody></table></center>


         <p>Most of the fields are fairly self-explanatory. The
         fields labeled as private at the end of the
         <code>CursorDeviceRec</code> are used to manage cursor
         acceleration, and shouldn't be modified by your software.
         Some of the usage of the other fields will be explained
         below in the description of the Cursor Device Manager
         routines.</p>



         <h3>Cursor Device Manager Routines</h3>

<h3>CursorDeviceNextDevice:</h3>
         
         <p><code>pascal OSErr CursorDeviceNextDevice(CursorDevicePtr
         *ourDevice);</code></p>
         
         <p><code>CursorDeviceNextDevice</code> can be used to index
         through the various devices the Cursor Device Manager is
         aware of. You pass it a <code>CursorDevicePtr</code>; initialize
         this variable to <code>nil</code> to get the first device in the
         list, then call <code>CursorDeviceNextDevice</code> repeatedly,
         each time passing the <code>CursorDevicePtr</code> as it was
         last modified; when you have reached the end of the device
         list, the pointer returned in the <code>curDevice</code>
         parameter will be 0.</p>
         
         <h3>CursorDeviceNewDevice:</h3>
         
         <p><code>pascal OSErr CursorDeviceNewDevice(CursorDevicePtr
         *ourDevice);</code></p>
         
         <p>Call <code>CursorDeviceNewDevice</code> to create a new
         cursor device and link it into the device chain. The new
         device record will be initialized with values representing a
         standard one-button mouse; you should call
         <code>CursorDeviceSetAcceleration</code> for the device after
         creating it. A pointer to the created device is returned in
         the <code>ourDevice</code> variable.</p>
         
         <p>New cursor devices are created for all ADB devices with a
         type 3 or 4 handler ID. This routine should only be needed
         by devices which are connected though some other method,
         such as the serial port.</p>
         
         <h3>CursorDeviceDisposeDevice:</h3>
         
         <p><code>pascal OSErr
         CursorDeviceDisposeDevice(CursorDevicePtr ourDevice);</code>
         </p>
         
         <p>This routine disposes of a cursor device and unlinks it
         from the device chain. This isn't needed by most developers,
         but could be useful for non-ADB devices which might be
         connected and disconnected.</p>
         
         <h3>CursorDeviceMove:</h3>
         
         <p><code>pascal OSErr CursorDeviceMove(CursorDevicePtr
         ourDevice,long deltaX,long deltaY);</code></p>
         
         <p><code>CursorDeviceMove</code> accumulates the
         <code>deltaX</code> and <code>deltaY</code> values into the
         recorded movement of the device; the next time the cursor
         position is calculated, these deltas will be fed through the
         acceleration algorithm and used to move the cursor. This
         routine should be called by a relative device driver with the
         data it receives from its device, even if the deltas are both
         zero.  This lets the acceleration algorithm properly calculate
         the appropriate motion. This routine is automatically called by
         the default driver for all devices with a type 3 or 4 handler
         ID. You would only need to call it if you were using an ADB
         device that isn't handled by the default driver, or a non-ADB
         device.</p>
         
         <h3><code>CursorDeviceMoveTo</code>:</h3>
         
         <p><code>pascal OSErr CursorDeviceMoveTo(CursorDevicePtr
         ourDevice,long absX,long absY);</code></p>
         
         <p><code>CursorDeviceMoveTo</code> sets the absolute position
         of the cursor to (<code>absX</code>, <code>absY</code>). The
         next time the cursor position is calculated, it will be moved
         to this absolute location. This would normally be used by a
         driver for an absolute pointing device to position the
         cursor.</p>
         
         <h3><code>CursorDeviceFlush</code>:</h3>
         
         <p><code>pascal OSErr CursorDeviceFlush(CursorDevicePtr
         ourDevice);</code></p>
         
         <p><code>CursorDeviceFlush</code> causes the acceleration and
         motion algorithms to flush out all their error collection
         and motion deltas into the cursor position: it indicates
         that your device is done moving temporarily. This may be
         useful for devices which can tell when they become idle
         (such as a stylus pointing device); if they call this
         routine when they become idle, it ensures that all unused
         motion data will be worked into the cursor position at the
         next time it is calculated.</p>
         
         <h3>CursorDeviceButtons:</h3>
         
         <p><code>pascal OSErr CursorDeviceButtons(CursorDevicePtr
         ourDevice,short buttons);</code></p>
         
         <p><code>CursorDeviceButtons</code> handles posting
         <code>mouseUp</code> and <code>mouseDown</code> events and also
         deals with debouncing mouse clicks. Pass the current button
         status in the <code>buttons</code> parameter, going from bit 0
         is button 0 to bit 7 representing button 7. For each button,
         a one-bit represents down, a zero-bit represents up. This
         routine debounces mouse clicks to keep them from looking
         like double clicks; if the button goes down less than 2
         ticks after coming up, then the <code>mouseDown</code> will be
         ignored. Button up events are never ignored to avoid
         problems such as continuous scrolling, which are confusing
         and difficult for the user to deal with. A device driver
         should call this routine any time it gets a data packet;
         this routine deals with keeping track of whether the button
         state has changed. This routine automatically calls routines
         installed with <code>CursorDeviceButtonOp</code>.</p>
         
         <h3>CursorDeviceButtonDown:</h3>
         
         <p><code>pascal OSErr
         CursorDeviceButtonDown(CursorDevicePtr
         ourDevice);</code></p>
         
         <p><code>CursorDeviceButtonDown</code> posts a
         <code>mouseDown</code> event if this is the first button to go
         down for this device. It is called by the standard button
         operation routines, and you should need to call it only if you
         use a custom button operation routine.</p>
         
         <h3>CursorDeviceButtonUp:</h3>
         
         <p><code><code>pascal OSErr
         CursorDeviceButtonUp(CursorDevicePtr ourDevice);</code></code>
         </p>
         
         <p><code>CursorDeviceButtonUp</code> posts a
         <code>mouseUp</code> event if this is the last button to come
         up for this device. It is called by the standard button
         operation routines; you should need to call it only if you use
         a custom button operation routine.</p>
         
         <h3>CursorDeviceButtonOp:</h3>
         
         <p><code>pascal OSErr CursorDeviceButtonOp(CursorDevicePtr
         ourDevice,short buttonNumber,ButtonOpcode opcode,long
         data</code><code><code>);</code></code></p>
         
         <p><code>CursorDeviceButtonOp</code> sets a new operation to be
         associated with a particular button. <code>btnNo</code> may
         range from 0 to 7, and <code>opCode</code> specifies what
         operation to use. The data field specifies a parameter for
         the operation you are setting for the
         <code>kButtonCustom</code> operation. The <code>opCode</code>
          parameter may have one of the following values:</p>
       
         <table border="1" width="500">
            <tbody><tr>
               <td align="left" width="157">
                  <code>kButtonNoOp</code>
               </td>
               <td align="left" width="250">
                  No action
               </td>
               </tr>
            <tr>
               <td align="left" width="157">
                  <code>kButtonSingleClick</code>
               </td><td align="left" width="250">
                  Normal mouse button
               </td></tr>
            <tr>
               <td align="left" width="157">
                  <code>kButtonDoubleClickkButton</code>
               </td>
               <td align="left" width="250">
                  Click, release, and click again when pressed
               </td></tr>
           <tr>
               <td align="left" width="157">
                  <code>kButtonClickLock</code>
               </td>
               <td align="left" width="250">
                  Click on press, release on next press
               </td></tr>
            <tr>
               <td align="left" width="157">Custom</td>
               <td align="left" width="250">Call a custom procedure; data holds its address
               </td>
               </tr>
         </tbody></table>
         <br>
         

         <p>Using the <code>btnCustom</code> operation will cause a
         procedure whose address is passed in data to be called
         whenever this button changes state. The procedure takes the
         following parameters: the address of the
         <code>CursorDeviceRec</code> record for its device is passed in
         register <code>A2</code>; the button being pressed or released
         is in register <code>D3</code>. The new state of the button will
         already have been filled into the buttons field in the
         <code>CursorDeviceRec</code>, so you may use that flag to
         determine if the button is being clicked or released. Your
         routine does not need to preserve registers <code>D0</code>,
         <code>D2</code>, <code>A0</code>, and <code>A1</code>; it must 
         preserve all others.</p>
         
         <p>The <code>kButtonCharStroke</code> and
         <code>kButtonAppleScript</code> operations are currently
         unimplemented and will simply cause the button press to be
         ignored.</p>
         
         <h3>CursorDeviceSetButtons:</h3>
         
         <p><code>pascal OSErr CursorDeviceSetButtons(CursorDevicePtr
         ourDevice,short
         numberOfButtons</code><code><code>);</code></code></p>
         
         <p><code>CursorDeviceSetButtons</code> allows you to set the
         number of buttons on the device specified by
         <code>ourDevice</code> to <code>numButtons</code>.</p>
         
         <h3>CursorDeviceSetAcceleration:</h3>
         
         <p><code>pascal OSErr
         CursorDeviceSetAcceleration(CursorDevicePtr ourDevice,Fixed
         acceleration</code><code><code>);</code></code></p>
         
         <p><code>CursorDeviceSetAcceleration</code> lets you set the
         acceleration for the device specified by <code>ourDevice</code>
         to the value specified by <code>acceleration</code>, where 0
         &lt;= <code>acceleration</code> &lt;= 1. The Cursor Device
         Manager will build an acceleration table for the device
         based on its device ID or device class and the desired
         acceleration value. For details on acceleration resources,
         see <a href="#Acceleration">"Acceleration Tables"</a>
         below. The acceleration table set by
         <code>CursorDeviceSetAcceleration</code> is found by
         interpolating the tables stored in the appropriate
         acceleration resource. All <code>'accl'</code> resources in the
         resource chain or in the ROM are searched looking for the
         one applying to the specified device, so a control panel
         which called <code>CursorDeviceSetAcceleration</code> could
         implicitly use <code>'accl'</code> resources stored within the
         control panel's resource fork.</p>
         
         <h3>CursorDeviceDoubleTime:</h3>
         
         <p>pascal OSErr CursorDeviceDoubleTime(CursorDevicePtr
         ourDevice;</p>
         
         <p><code>duration: LongInt);</code></p>
         
         <p><code>CursorDeviceDoubleTime</code> lets you set the
         double-click time associated with a particular device. The
         duration parameter specifies the time, in ticks, to use as
         the double-click time for this device. An application could
         be written to check the double-click time for the particular
         device in checking for a double-click.</p>
         
         <h3>CursorDeviceUnitsPerInch:</h3>
         
         <p>pascal OSErr C<code>ursorDeviceUnitsPerInch(CursorDevicePtr
         ourDevice;</code></p>
         
         <p><code>resolution: Fixed);</code></p>
         
         <p><code>CursorDeviceUnitsPerInch</code> lets you set the
         resolution of a particular device to its physical
         resolution, in units per inch. For devices adhering to the
         Apple extended mouse protocol, this call shouldn't be
         needed, as the resolution can be read from the device's
         register 1; however, this call might be made by a driver for
         a device which doesn't use the ADB.</p>
         
         <a name="Acceleration"></a> 
    <h3>Acceleration Tables</h3>
         
         <p>Acceleration tables are stored in resources of type
         <code>'accl'</code>, which have the following <code>Rez</code> 
         description:
         </p>

         
    <center><table border="0" cellpadding="5" width="550">
<tbody><tr>
	<td align="left" bgcolor="#e6e6e6">
<pre>type 'accl' {
    literal longInt /* Device identifier or device class */
    classAbsolute, /* A flat-response device */
    classMouse, /* Mechanical or optical mouse */
    classTrackball; /* Trackball */
&nbsp;
    integer = $$CountOf(AcclTable);
    /* Number of tables for this device */
    array AcclTable
    { /* Entries sorted by first value; must have */ /* at least 0.0 and 1.0 tables */
        unsigned hex longint;
        /* Acceleration provided by this table (Fixed) */
&nbsp;
        integer = $$CountOf(AcclPoint); /* Number of control points for this device */
        wide array AcclPoint { /* Entries sorted by first value; implicit */
            /* first entry (0.0, 0.0); at least one more */
            /* entry required. */
            unsigned hex longint; /* Device speed (inches per second) (Fixed) */
            unsigned hex longint; /* Cursor speed (inches per second) (Fixed) */
        };
    };
};</pre>
	</td>
</tr>
</tbody></table></center>
 
 
         <p>The identifier for this <code>'accl'</code> resource is
         stored in the first long word; this is either an
         <code>OSType</code> four-character device identifier or an
         integer value specifying the device class. In either case,
         the device's identity is generally read from the device's
         register 1, as described below in the section
         <a href="#Extended">"Extended Apple
         Mouse Protocol."</a> The Cursor Device Manager first tries
         to match against the specific device identifier, then
         against the more general class. Each <code>'accl'</code>
         resource can contain a number of acceleration tables for
         different acceleration values; each table contains a number
         of entries that match a particular device speed to a
         particular cursor speed. An <code>'accl'</code> resource must
         contain at least two acceleration tables, one for an
         acceleration of 0.0, and one for an acceleration value of
         1.0. When an acceleration value is set for a particular
         device, the acceleration table is calculated by
         interpolating between the two nearest tables from the
         <code>'accl'</code> resource. There is an implicit entry in
         each acceleration table of (0.0, 0.0), which indicates that the
         cursor should not move if the device does not. At least one
         additional entry is required; the Cursor Device Manager will
         use the table entries to figure the cursor movement by using
         the device movement to interpolate based on the specified
         movement control points.</p>
         
         <h3>Availability Of The Cursor Device Manager</h3>
         
         <p>The Cursor Device Manager was introduced in the ROMs of
         Macintoshes introduced in February, 1993. It may be
         installed via software on any Macintosh. To check to see if
         the Cursor Device Manager is available, you should use the
         standard <code>TrapAvailable</code> routine to check to see if
         its trap is implemented. The Cursor Device Manager trap is
         <code>$AADB</code>, making it a toolbox trap, trap number
         <code>$2DB</code>.</p>
         
         <center><table border="0" cellpadding="5" width="550">
<tbody><tr>
	<td align="left" bgcolor="#e6e6e6">
<pre>#include &lt;Traps.h&gt;
#include &lt;OSUtils.h&gt;
&nbsp;
static Boolean CursorDeviceManagerAvailable(void)
{
    return GetToolboxTrapAddress(_CursorDeviceDispatch) !=
            GetToolboxTrapAddress(_Unimplemented);
}</pre>
	</td>
</tr>
</tbody></table></center>
         
         <h3>Compatibility</h3>
         
         <p>When the Cursor Device Manager is installed, all Apple
         mouse drivers use its interface to move the cursor; this
         means that the low memory globals such as <code>Mouse</code>
         and <code>RawMouse</code> are no longer used. While a
         compatibility mode keeps drivers which still modify these
         globals continue to work, the cursor position can no longer be
         read from these globals.
      </p>

         <p><a href="#top">Back to top</a></p><a name="Section5"></a><h2>Using
         the CursorDevice Manager in Native Code</h2>
         
         <p>With the original release of the <code>CursorDevice</code>
         Manager, a problem was introduced in the native
         <code>InterfaceLib</code> code such that the glue
         code for the following <code>CrsrDev</code> calls was
         broken.</p>
         
         <p><code>extern pascal OSErr CrsrDevButtons(CrsrDevicePtr
         ourDevice);</code></p>
         
         <p><code>extern pascal OSErr CrsrDevButtonOp(CrsrDevicePtr
         ourDevice);</code></p>
         
         <p><code>extern pascal OSErr CrsrDevSetButtons(CrsrDevicePtr
         ourDevice);</code></p>
         
         <p><code>extern pascal OSErr
         CrsrDevSetAcceleration(CrsrDevicePtr ourDevice);</code></p>
         
         <p><code>extern pascal OSErr CrsrDevDoubleTime(CrsrDevicePtr
         ourDevice);</code></p>
         
         <p><code>extern pascal OSErr
         CrsrDevUnitsPerInch(CrsrDevicePtr ourDevice);</code></p>
         
         <p>To address this problem, an updated set of
         <code>CursorDevices</code> interfaces were released in which
         the calls were modified by changing the call prefix to
         <code>CursorDevice</code>.... This change introduced a new
          problem. One could no longer link <code>CursorDevice</code>
          Manager calls with the <code>InterfaceLib</code> stub
         library.  To address this new issue, the "CursorDevices.Glue.c"
         file was made available. The downside of using this code was
         that it statically linked to the 68K ADB trap code. If in a
         future release of MacOS, we were to fix a problem with the
         <code>CursorDevice</code> Manager, code linked to
         "CursorDevices.Glue.c" might not benefit from these fixes. 
         </p>
         
         <p>Since the release of ETO #24, there is now the
         "CursorDevicesGlue.o" object library which all
         <code>CursorDevice</code> Manager processes should link with.
         This library will properly detect for an updated
         <code>CursorDevice</code> Manager, else use 
         the existing 68K ADB trap code. This library expects one
         to use the <code>CursorDevice</code>... calls as prototyped in
         the <code>CursorDevices</code> interface files.</p>


         <p><a href="#top">Back to top</a></p><h2><a name="Section6"></a>Apple Devices</h2>
         
         <h3>Classic Apple Mouse Protocol</h3>
         
         <p>The original Apple mouse protocol allows for mice with a
         resolution of 100 or 200 units per inch with 7-bit
         accumulation of relative movement with one or two buttons.
         Handler ID 1 was used to indicate 100 cpi operation; handler
         2 to indicate 200 cpi operation. All data is transferred
         through register 0 in the following format:</p>
         
         <p align="center"><img src="hw_01_files/hw_01_001.gif" alt="Classic Mouse Register 0 Format" align="bottom" width="480" height="109"></p>
         
         <p align="center"><b>Figure 1</b> - Classic Mouse Register 0 Format</p>
         
         <p>A relative motion in each axis is accumulated until
         fetched with a talk register 0 command sent by the host. The
         X value represents left-to-right motion. The Y value holds
         accumulated forward-to-back motion.</p>
         
         <a name="Extended"></a><h3>Extended
         Apple Mouse Protocol</h3>
         
         <p>In order to take advantage of the higher movement 
         resolution support available with the <code>CursorDevice</code>
         Manager, an extended mouse protocol has been defined. The
         extended mouse protocol allows a device to communicate up to
         16 bits of movement data with each polling, and allows a
         standard device to communicate the state of up to 8 buttons.
         In addition, the new format allows each device to
         communicate its exact type, resolution, and class. This new
         format applies to all relative devices at default address 3,
         handler ID 4.</p>
         
         <p>During startup or after a reset of the ADB bus, devices
         which power up at default address 3 with handler ID 1 will
         be switched to handler ID 4 with a listen register 3
         command. If the device accepts the switch and reports the
         new handler ID of 4 back in response to a talk register 3
         command, all subsequent communication with the device will
         be assumed to follow the extended mouse protocol. Currently,
         the ADB Manager makes an additional check, making sure that
         a talk register 1 returns 8 bytes (the format of register 1
         is specified below). If a device accepts a handler ID change
         but does not return 8 bytes from register 1, it is assumed
         to not actually be an extended mouse protocol device and it is
         switched back to its original handler ID.</p>
         
         <p>All movement and button data still passes through
         register 0, which can now hold between 2 and 5 bytes, where
         2 bytes provides the device with the data transfer
         capability of the original mouse protocol and additional
         bytes allow added resolution and buttons.</p>
         
         <p>Bytes 0 and 1 of register 0 have the same format as they
         did in the classic mouse protocol, communicating the state
         of the first two buttons and the low order 7 bits of the
         accumulated motion in the X and Y axes. There can be up to 3
         bytes of additional information: each one of these bytes can
         communicate the state of 2 more buttons and add 3 higher
         order bits of resolution to each of the X and Y axes. The
         format of each additional byte is:</p>
         
         <p align="center"><img src="hw_01_files/hw_01_002.gif" alt="Format Of Additional Register 0 Bytes For         Extended Mouse Protocol" align="bottom" width="352" height="109">
         </p>
         
         <p align="center"><b>Figure 2</b> - Format Of Additional Register 0 Bytes For
         Extended Mouse Protocol</p>
         
         <p>As a specific example, in a maximal 5-byte transmission,
         the data would be transferred in this format:</p>
         
         <table border="1">
            <tbody><tr>
               <td align="left">
                  <p>Bit #:</p>
               </td><td align="left">
                  <p>7</p>
               </td><td align="left">
                  <p>6</p>
               </td><td align="left">
                  <p>5</p>
               </td><td align="left">
                  <p>4</p>
               </td><td align="left">
                  <p>3</p>
               </td><td align="left">
                  <p>2</p>
               </td><td align="left">
                  <p>1</p>
               </td><td align="left">
                  <p>0</p>
               </td></tr>
            <tr>
               <td align="left">
                  <p>Byte 0:</p>
               </td><td align="left">
                  <p>b0</p>
               </td><td align="left">
                  <p>y06</p>
               </td><td align="left">
                  <p>y05</p>
               </td><td align="left">
                  <p>y04</p>
               </td><td align="left">
                  <p>y03</p>
               </td><td align="left">
                  <p>y02</p>
               </td><td align="left">
                  <p>y01</p>
               </td><td align="left">
                  <p>y00</p>
               </td></tr>
            <tr>
               <td align="left">
                  <p>Byte 1:</p>
               </td><td align="left">
                  <p>b1</p>
               </td><td align="left">
                  <p>x06</p>
               </td><td align="left">
                  <p>x05</p>
               </td><td align="left">
                  <p>x04</p>
               </td><td align="left">
                  <p>x03</p>
               </td><td align="left">
                  <p>x02</p>
               </td><td align="left">
                  <p>x01</p>
               </td><td align="left">
                  <p>x00</p>
               </td></tr>
            <tr>
               <td align="left">
                  <p>Byte 2:</p>
               </td><td align="left">
                  <p>b2</p>
               </td><td align="left">
                  <p>y09</p>
               </td><td align="left">
                  <p>y08</p>
               </td><td align="left">
                  <p>y07</p>
               </td><td align="left">
                  <p>b3</p>
               </td><td align="left">
                  <p>x09</p>
               </td><td align="left">
                  <p>x08</p>
               </td><td align="left">
                  <p>x07</p>
               </td></tr>
            <tr>
               <td align="left">
                  <p>Byte 3:</p>
               </td><td align="left">
                  <p>b4</p>
               </td><td align="left">
                  <p>y12</p>
               </td><td align="left">
                  <p>y11</p>
               </td><td align="left">
                  <p>y10</p>
               </td><td align="left">
                  <p>b5</p>
               </td><td align="left">
                  <p>x12</p>
               </td><td align="left">
                  <p>x11</p>
               </td><td align="left">
                  <p>x10</p>
               </td></tr>
            <tr>
               <td align="left">
                  <p>Byte 4:</p>
               </td><td align="left">
                  <p>b6</p>
               </td><td align="left">
                  <p>y15</p>
               </td><td align="left">
                  <p>y14</p>
               </td><td align="left">
                  <p>y13</p>
               </td><td align="left">
                  <p>b7</p>
               </td><td align="left">
                  <p>x15</p>
               </td><td align="left">
                  <p>x14</p>
               </td><td align="left">
                  <p>x13</p>
               </td></tr>
         </tbody></table><br>
         
         <h3>Table 2 - Format of a 5-Byte Register 0 Data
         Transfer</h3>
         
         <p>Where b<i>n</i> indicates the status of button <i>n</i>
         and x<i>aa</i> or y<i>bb</i> indicates the value of bit
         <i>aa</i> or <i>bb</i> of the X or Y movement.</p>
         
         <p>In addition, register 1 is used in the extended mouse
         protocol to provide some general information about the
         device. Register 1 is 8 bytes long and is formatted in this
         way:</p>
 
         
         <table border="1">
            <tbody><tr>
               <td align="left" width="137">
                  <p>Byte Range</p>
               </td><td align="left">
                  <p>Format</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>0-3</p>
               </td><td align="left">
                  <p>Unique device identifier</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>4-5</p>
               </td><td align="left">
                  <p>Device resolution in units/inch</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>6</p>
               </td><td align="left">
                  <p>Device class (Mouse, trackball, etc.)</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>7</p>
               </td><td align="left">
                  <p>Number of buttons (0-8)</p>
               </td></tr>
         </tbody></table><br>
         
         <h3>Table 3 - Format Of Extended Mouse Protocol
         Register 1</h3>
         

         <p>The unique device identifier is intended to be a 
         four-character ASCII identifier similar to the
         <code>OSType</code> identifiers used as types and creators in
         the Macintosh file system; they can be registered using the
         same mechanism used to register creator types. A developer 
         should only use a device identifier in this field if they have
         obtained a registration for that identifier's use as a creator 
         from Apple.</p>
         
         <p>The device class is a value which is used to identify the
         type of device and to control the acceleration curve used
         for that device. The currently defined constants include:
         </p>
         
         <table border="1">
            <tbody><tr>
               <td align="left" width="137">
                  <p>Device Constant</p>
               </td><td align="left">
                  <p>Device Type</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>0</p>
               </td><td align="left">
                  <p>Tablet device (absolutely positioned)</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>1</p>
               </td><td align="left">
                  <p>Mouse</p>
               </td></tr>
            <tr>
               <td align="left" width="137">
                  <p>2</p>
               </td><td align="left">
                  <p>Trackball</p>
               </td></tr>
         </tbody></table>
         <br>
         <h3>Table 4 - Currently defined device classes</h3>
         
         <p>There currently isn't any mechanism for developers to
         create or register device classes; if a developer needs a
         device class not available from Apple, the only alternative
         available currently is not to use the handler ID 4 extended
         mouse protocol.  Instead they should use a custom handler ID
         and custom driver software.</p>
         
         <h3>Apple Keyboard Protocol</h3>
         
         <p>The Apple keyboards have a simple data transfer protocol.
         Register 0 is used to inform the host as keys are depressed
         and released; register 2 is used to communicate the state of
         the modifier keys and to control the LED indicators on the
         extended keyboards.</p>
         
         <p>The format of register 0 is:</p>
         
         <p align="center"><img src="hw_01_files/hw_01_003.gif" alt="Keyboard Register 0 Format" align="bottom" width="448" height="109">
         </p>
         
         <p align="center"><b>Figure 3</b> - Keyboard Register 0 Format</p>
         
         <p>Register 0 can communicate up to two key transitions at
         once. Each transition consists of a key code and a key
         released bit, which is 0 for key depressions and 1 for key
         releases. The key codes are described in <i>Inside
         Macintosh</i> volume V, pages 191-192. The special case is
         the reset key, which returns the value <code>$7F7F</code> in
         register 0 when it is depressed and <code>$FFFF</code> when
         released; thus, it uses both key code positions within register
         0.</p>
         
         <p>The format of register 2 is:</p>
         
         <p align="center"><img src="hw_01_files/hw_01_004.gif" alt="Keyboard Register 2 Format" align="bottom" width="448" height="290">
         </p>
         
         <p align="center"><b>Figure 4</b> - Keyboard Register 2 Format</p>
         
         <p>The current state of the keys listed in figure 4 is
         available in bits 6-14 of register 2, if those keys exist on
         the keyboard being examined. Bits 0-2 hold the current state
         of the LEDs on the extended keyboard; the states of these
         LEDs can be changed by sending the keyboard a listen
         register 2 command. Note that key transition events are
         generated in register 0 for modifier keys, as they are for
         all other keys; these keys are available in register 2 in
         addition to their status being transmitted through register
         0.</p>
      

         <a name="Licensing"></a><p><a href="#top">Back to top</a></p><h2>Licensing</h2>
         
         <p>The Apple Desktop Bus is patented. In order to build an
         ADB device, you will need to get a license from Apple.</p>
         
         <p>Contact our <a href="http://developer.apple.com/mkt/registering/swl/llsw.html">
         Software Licensing department</a> at
         <a href="mailto:sw.license@apple.com">sw.license@apple.com</a> 
         or 800-793-9378 or 512-919-2645.</p>
         
         <p>The license is available for a nominal fee in most cases,
         and the licensing package includes the latest version of the
         ADB specification, which is the definitive reference to the
         bus.</p>
      

<a name="References"></a><p><a href="#top">Back to top</a></p><h2>References</h2>


            <p>The Apple Desktop Bus specification, revision F.</p>
            
            <p><i>Inside Macintosh</i>, Volume V, chapter 20, "The
            Apple Desktop Bus."</p>
            
            <p><i>Guide to the Macintosh Family Hardware</i>, Second
            Edition, Chapter 8, "Apple Desktop Bus."</p>
      
      
      <a name="changes"></a>
         
         <p><a href="#top">Back to top</a></p><h2>Change History</h2>
         
       
         
         <table border="0" cellpadding="3" width="544">
            <tbody><tr>
               <td align="left" width="100">
                  <p align="center">1-October-1991</p>
               </td>
               <td align="left">
                  <p>New information appears throughout the document.
         In particular, the Cursor Device Manager is discussed in
         this note for the first time. The information regarding bugs
         fixed in System 6.0.4 was omitted.</p>
               </td>
            </tr>
 <tr>
               <td align="left" width="100">
                  <p align="center">1-January-1994</p>
               </td>
               <td align="left">
                  <p>The Cursor Device
         Manager API has been updated for Universal Headers 3.1 and
         some issues with ROM bugs have been documented.</p>
               </td>
            </tr>
 </tbody></table><br>


<p><a href="#top">Back to top</a></p>

<p><a name="Downloads"></a></p>
         
         <h2>Downloadables</h2>
         
         <table border="0" cellpadding="3" width="100%">
            <tbody><tr>
               <td align="left" width="50">
                  <p align="center"><img src="hw_01_files/acrobatsmall.gif" alt="Acrobat gif" align="middle" width="22" height="23"></p>
               </td>
               <td align="left">
                  <p>Acrobat version of this Note (252K)</p>
               </td>
               <td align="left" width="60">
                  <p><a href="http://developer.apple.com/technotes/hw/pdf/hw_01.pdf">Download</a></p>
               </td>
            </tr>
</tbody></table><br>

<p><a href="#top">Back to top</a></p>
</td></tr></tbody></table></center>
<!-- end_content -->
<!-- begin_footer_information -->	<table border="0" cellpadding="0" cellspacing="0" width="680">
		<tbody><tr>
			<td><img src="hw_01_files/1dot.gif" alt="" width="680" height="5"><br><img src="hw_01_files/1dot_919699.gif" alt="" width="100%" height="1"><br><img src="hw_01_files/1dot.gif" alt="" width="680" height="15"></td>
		</tr>
		<tr>
			<td align="center"><br>
				<table class="graybox" border="0" cellpadding="0" cellspacing="0">
					<tbody><tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td><a href="http://developer.apple.com/feedback/?v=1" target="_blank">Yes</a>:  Tell us what works for you.<br><img src="hw_01_files/1dot.gif" alt="" width="10" height="8"><br>
							<a href="http://developer.apple.com/feedback/?v=2" target="_blank">Its good, but:</a> Report typos, inaccuracies, and so forth.<br><img src="hw_01_files/1dot.gif" alt="" width="10" height="8"><br>
							<a href="http://developer.apple.com/feedback/?v=3" target="_blank">It wasnt helpful</a>: Tell us what would have helped.</td>
					</tr>
				</tbody></table>
			</td>
		</tr>
	</tbody></table>
	<!-- googleoff: all -->
	<!-- START FOOTER TABLE -->
	<div id="footer" align="center">
	<table border="0" cellpadding="0" cellspacing="0" width="680">
		<tbody><tr>
			<td><img src="hw_01_files/1dot_919699.gif" alt="" width="680" height="1"><br>
			<img src="hw_01_files/1dot.gif" alt="" width="680" height="17"></td>
		</tr>
		<tr>
			<td align="center">
				<p>Get information on <a href="http://www.apple.com/" target="_top">Apple</a> products.<br>
				Visit the Apple Store <a href="http://store.apple.com/" target="_top">online</a> or at <a href="http://www.apple.com/retail/" target="_top">retail</a> locations.<br>
				1-800-MY-APPLE</p>
				<p>Copyright  2009 Apple Inc.<br>
				<a href="http://www.apple.com/legal/" target="_top">All rights reserved.</a> | <a href="http://www.apple.com/legal/" target="_top">Terms of use</a> | <a href="http://www.apple.com/legal/privacy/" target="_top">Privacy Notice</a></p>
			</td>
		</tr>
		<tr>
			<td><img src="hw_01_files/1dot.gif" alt="" width="680" height="20"></td>
		</tr>
	</tbody></table>
	</div>
	<!-- END FOOTER TABLE -->
	<!-- googleon: all -->
<!-- end_footer_information -->

</center></body></html>